---
title: "CryptoHack: Modular Arithmetic"
date: 2022-10-29T20:05:14-07:00
draft: false
summary: "Writeups for CryptoHack's Modular Arithmetic Course"
description: "Writeups for CryptoHack's [Modular Arithmetic Course](https://cryptohack.org/courses/modular/course_details/)"
categories: ["cryptohack"]
tags: ["crypto"]
cover:
    image: "img/cryptohack/cover.png"
---

## Greatest Common Divisor
>The Greatest Common Divisor (`GCD`), sometimes known as the highest common factor, is the largest number which divides two positive integers (`a`,`b`).
>
>For `a = 12`, `b = 8` we can calculate the divisors of `a: {1,2,3,4,6,12}` and the divisors of `b: {1,2,4,8}`. Comparing these two, we see that `gcd(a,b) = 4`.
>
>Now imagine we take `a = 11`, `b = 17`. Both `a` and `b` are prime numbers. As a prime number has only itself and `1` as divisors, `gcd(a,b) = 1`.
>
>We say that for any two integers `a,b`, if `gcd(a,b) = 1` then a and b are **coprime** integers.
>
>If `a` and `b` are prime, they are also coprime. If `a` is prime and `b` < `a` then `a` and `b` are coprime.
>There are many tools to calculate the GCD of two integers, but for this task we recommend looking up [Euclid's Algorithm](https://en.wikipedia.org/wiki/Euclidean_algorithm).
>
>Try coding it up; it's only a couple of lines. Use `a = 12, b = 8` to test it.
>
>Now calculate `gcd(a,b)` for `a = 66528, b = 52920` and enter it below.

`Euclid's Algorithm` pseudocode:
```java
function gcd(a, b)
    while a ≠ b 
        if a > b
            a := a − b
        else
            b := b − a
    return a
```
```java
function gcd(a, b)
    if b = 0
        return a
    else
        return gcd(b, a mod b)
```

### Solution

```python
def gcd(a,b):
    if b == 0:
        return a
    else:
        return gcd(b, a % b)
```
```console {linenos=false}
> gcd(12, 8)
4
> gcd(66528, 52920)
1512
```

## Extended GCD
>Let `a` and `b` be positive integers.
>
>The extended Euclidean algorithm is an efficient way to find integers `u,v` such that `a * u + b * v = gcd(a,b)`
>
>Using the two primes `p = 26513, q = 32321`, find the integers `u,v` such that `p * u + q * v = gcd(p,q)`
>
>Enter whichever of u and v is the lower number as the flag.

### Solution
I watched [this video](https://www.youtube.com/watch?v=hB34-GSDT3k) and read [this article](http://www-math.ucdenver.edu/~wcherowi/courses/m5410/exeucalg.html) to better understand the extended Euclidean Algorithm.
```python
# source: https://www.geeksforgeeks.org/python-program-for-basic-and-extended-euclidean-algorithms-2/

# function for extended Euclidean Algorithm
def gcdExtended(a, b):
    # Base Case
    if a == 0 :
        return b,0,1

    gcd,x1,y1 = gcdExtended(b%a, a)

    # Update x and y using results of recursive call
    x = y1 - (b//a) * x1
    y = x1

    return gcd,x,y
```

```console {linenos=false}
> gcdExtended(26513, 32321)
(1, 10245, -8404)
> min(10245, -8404)
-8404
```

## Modular Arithmetic 1
> Imagine you lean over and look at a cryptographer's notebook. You see some notes in the margin:
```{linenos=false}
4 + 9 = 1
5 - 7 = 10
2 + 3 = 5
```
>At first you might think they've gone mad. Maybe this is why there are so many data leaks nowadays you'd think, but this is nothing more than modular arithmetic modulo 12 (albeit with some sloppy notation).
>
>You may not have been calling it modular arithmetic, but you've been doing these kinds of calculations since you learnt to tell the time (look again at those equations and think about adding hours).
>
>Formally, "calculating time" is described by the theory of congruences. We say that two integers are congruent modulo m if `a ≡ b mod m`.
>
>Another way of saying this, is that when we divide the integer `a` by `m`, the remainder is `b`. This tells you that if m divides a (this can be written as `m | a`) then `a ≡ 0 mod m`.
>
>Calculate the following integers:
```{linenos=false}
11 ≡ x mod 6
8146798528947 ≡ y mod 17
```
>The solution is the smaller of the two integers.

### Solution
[*if `a ≡ b mod m`, then `b ≡ a mod m`.*](chrome-extension://efaidnbmnnnibpcajpcglclefindmkaj/https://www.math.nyu.edu/~hausner/congruence.pdf)

So:
``` {linenos=false}
11 ≡ x mod 6 -> x ≡ 11 mod 6 -> x ≡ 5

8146798528947 ≡ y mod 17 -> y ≡ 8146798528947 mod 17 -> y ≡ 4
```
```console {linenos=false}
> min(11 % 6, 8146798528947 % 17)
4
```

## Modular Arithmetic 2
>We'll pick up from the last challenge and imagine we've picked a modulus `p`, and we will restrict ourselves to the case when `p` is prime.
>
>The integers modulo `p` define a field, denoted `Fp`.
>
>A finite field `Fp` is the set of integers `{0,1,...,p-1}`, and under both addition and multiplication there is an inverse element `b` for every element `a` in the set, such that `a + b = 0` and `a * b = 1`.
>
>Lets say we pick `p = 17`. Calculate `3^17 mod 17`. Now do the same but with `5^17 mod 17`.
>
>What would you expect to get for `7^16 mod 17`? Try calculating that.
>
>This interesting fact is known as Fermat's little theorem. We'll be needing this (and its generalisations) when we look at RSA cryptography.
>
>Now take the prime `p = 65537`. Calculate `273246787654^65536 mod 65537`.
>
>Did you need a calculator?

### Solution
In summary, [Fermat's Little Theorem](https://en.wikipedia.org/wiki/Fermat%27s_little_theorem) states that:

```{linenos=false}
if p is prime, for every integer a:
    pow(a, p) = a mod p
and, if p is prime and a is an integer coprime with p:
    pow(a, p-1) = 1 mod p
```

So:
```python
from math import gcd

a = 273246787654
p = 65537

if gcd(a,p) == 1:
    print("Coprime! Solution is 1")
```

## Modular Inverting
> As we've seen, we can work within a finite field `Fp`, adding and multiplying elements, and always obtain another element of the field.
>
>For all elements `g` in the field, there exists a unique integer `d` such that `g * d ≡ 1 mod p`.
>
>This is the multiplicative inverse of `g`.
>
>Example: `7 * 8 = 56 ≡ 1 mod 11`
>
>What is the inverse element: `3 * d ≡ 1 mod 13`?

### Solution
Followed [this tutorial](https://www.khanacademy.org/computing/computer-science/cryptography/modarithmetic/a/modular-inverses).
```python
# a = 3
# c = 13
def imod(a,c):
    for i in range(c-1):
        if a*i == 1%c:
            return i
```
```console {linenos=false}
> print(imod(7,11))
8
> print(imod(3,13))
9
```

Alternate solution(s):
```python
# source: CryptoHack user @Hon

'''
Looking again at Fermat's little theorem...
if p is prime, for every integer a:
        pow(a, p) = a mod p
and, if p is prime and a is an integer coprime with p:
        pow(a, p-1) = 1 mod p
We can do some magic like this:
Note: i'll use math notation, so a^b means pow(a,b)
        a^(p-1) = 1 (mod p)
        a^(p-1) * a^-1 = a^-1 (mod p)
        a^(p-2) * a * a^-1 = a^-1 (mod p)
        a^(p-2) * 1 = a^-1 (mod p)
So finally we have:
        a^(p-2) = a^-1 (mod p)
So, doing a^(p-2) and then (mod p) we can achieve
our result
'''
a = 3
p = 13
print(pow(a,p-2) % p)
```

```python
# source: CryptoHack user @DaBaddest

'''
The problem given is 3 * d ≡ 1 mod 13
To calculate d we can divide both sides by 3 which gives us
  d = (1/3) * 1 mod 13
which is equivalent to
  d = 3^-1 mod 13, where ^ symbol is raised to the power of
We can easily convert this into python equation using the pow function
'''

print(pow(3, -1, 13))
```

## Quadratic Residues
>We've looked at multiplication and division in modular arithmetic, but what does it mean to take the square root modulo an integer?
>
>For the following discussion, let's work modulo `p = 29`. We can take the integer `a = 11` and calculate `a^2 = 5 mod 29`.
>
>As `a = 11`, `a^2 = 5`, we say the square root of `5` is `11`.
>
>This feels good, but now let's think about the square root of `18`. From the above, we know we need to find some integer a such that `a^2 = 18`
>
>Your first idea might be to start with `a = 1` and loop to `a = p-1`. In this discussion p isn't too large and we can quickly look.
>
>Have a go, try coding this and see what you find. If you've coded it right, you'll find that for all `a ∈ Fp*` you never find an a such that `a^2 = 18`.
>
>What we are seeing, is that for the elements of `F*p`, not every element has a square root. In fact, what we find is that for roughly one half of the elements of `Fp*`, there is no square root.
>
>In other words, `x` is a quadratic residue when it is possible to take the square root of `x` modulo an integer `p`.
>
>In the below list there are two non-quadratic residues and one quadratic residue.
>
>Find the quadratic residue and then calculate its square root. Of the two possible roots, submit the smaller one as the flag.

```{linenos=false}
p = 29
ints = [14, 6, 11]
```

### Solution
```python
p = 29
ints = [14, 6, 11]

qr = [a for a in range(p-1) if pow(a,2,p) in ints]
print(min(qr))
```

```{linenos=false}
8
```

## Legendre Symbol
>In Quadratic Residues we learnt what it means to take the square root modulo an integer. We also saw that taking a root isn't always possible.
>
>In the previous case when `p = 29`, even the simplest method of calculating the square root was fast enough, but as `p` gets larger, this method becomes wildly unreasonable.
>
>Lucky for us, we have a way to check whether an integer is a quadratic residue with a single calculation thanks to Legendre. In the following, we will assume we are working modulo a prime p.
>
>Before looking at Legendre's symbol, let's take a brief detour to see an interesting property of quadratic (non-)residues.
```{linenos=false}
Quadratic Residue * Quadratic Residue = Quadratic Residue
Quadratic Residue * Quadratic Non-residue = Quadratic Non-residue
Quadratic Non-residue * Quadratic Non-residue = Quadratic Residue
```
>So what's the trick? The [Legendre Symbol](https://en.wikipedia.org/wiki/Legendre_symbol) gives an efficient way to determine whether an integer is a quadratic residue modulo an odd prime p.
>
>Legendre's Symbol: `(a / p) ≡ a^(p-1)/2 mod p` obeys:
```{linenos=false}
(a / p) = 1 if a is a quadratic residue and a ≢ 0 mod p
(a / p) = -1 if a is a quadratic non-residue mod p
(a / p) = 0 if a ≡ 0 mod p
```
>Which means given any integer a, calculating `pow(a,(p-1)/2,p)` is enough to determine if a is a quadratic residue.
>
>Now for the flag. Given the following 1024 bit prime and 10 integers, find the quadratic residue and then calculate its square root; the square root is your flag. Of the two possible roots, submit the larger one as your answer.
>
>Challenge files:
>  - output.txt

*file: output.txt*
```
p = 101524035174539890485408575671085261788758965189060164484385690801466167356667036677932998889725476582421738788500738738503134356158197247473850273565349249573867251280253564698939768700489401960767007716413932851838937641880157263936985954881657889497583485535527613578457628399173971810541670838543309159139

ints = [25081841204695904475894082974192007718642931811040324543182130088804239047149283334700530600468528298920930150221871666297194395061462592781551275161695411167049544771049769000895119729307495913024360169904315078028798025169985966732789207320203861858234048872508633514498384390497048416012928086480326832803, 45471765180330439060504647480621449634904192839383897212809808339619841633826534856109999027962620381874878086991125854247108359699799913776917227058286090426484548349388138935504299609200377899052716663351188664096302672712078508601311725863678223874157861163196340391008634419348573975841578359355931590555, 17364140182001694956465593533200623738590196990236340894554145562517924989208719245429557645254953527658049246737589538280332010533027062477684237933221198639948938784244510469138826808187365678322547992099715229218615475923754896960363138890331502811292427146595752813297603265829581292183917027983351121325, 14388109104985808487337749876058284426747816961971581447380608277949200244660381570568531129775053684256071819837294436069133592772543582735985855506250660938574234958754211349215293281645205354069970790155237033436065434572020652955666855773232074749487007626050323967496732359278657193580493324467258802863, 4379499308310772821004090447650785095356643590411706358119239166662089428685562719233435615196994728767593223519226235062647670077854687031681041462632566890129595506430188602238753450337691441293042716909901692570971955078924699306873191983953501093343423248482960643055943413031768521782634679536276233318, 85256449776780591202928235662805033201684571648990042997557084658000067050672130152734911919581661523957075992761662315262685030115255938352540032297113615687815976039390537716707854569980516690246592112936796917504034711418465442893323439490171095447109457355598873230115172636184525449905022174536414781771, 50576597458517451578431293746926099486388286246142012476814190030935689430726042810458344828563913001012415702876199708216875020997112089693759638454900092580746638631062117961876611545851157613835724635005253792316142379239047654392970415343694657580353333217547079551304961116837545648785312490665576832987, 96868738830341112368094632337476840272563704408573054404213766500407517251810212494515862176356916912627172280446141202661640191237336568731069327906100896178776245311689857997012187599140875912026589672629935267844696976980890380730867520071059572350667913710344648377601017758188404474812654737363275994871, 4881261656846638800623549662943393234361061827128610120046315649707078244180313661063004390750821317096754282796876479695558644108492317407662131441224257537276274962372021273583478509416358764706098471849536036184924640593888902859441388472856822541452041181244337124767666161645827145408781917658423571721, 18237936726367556664171427575475596460727369368246286138804284742124256700367133250078608537129877968287885457417957868580553371999414227484737603688992620953200143688061024092623556471053006464123205133894607923801371986027458274343737860395496260538663183193877539815179246700525865152165600985105257601565]
```

### Solution
[Tonelli–Shanks algorithm](https://en.wikipedia.org/wiki/Tonelli%E2%80%93Shanks_algorithm)is used to find the square root of `n mod p`. 

*Note: Tonelli-Shanks doesn't work for composite (non-prime) moduli. Finding square roots modulo composites is computationally equivalent to integer factorization.*

Since `p = 3 mod 4` is hinted to us, we can concude:
![tonelli](/img/cryptohack/tonelli.png)
\[ *image source: https://medium.com/@pavanipoluru.21.01/cryptohack-mathematics-d0f691fffe4e* \]

```python
p = 101524035174539890485408575671085261788758965189060164484385690801466167356667036677932998889725476582421738788500738738503134356158197247473850273565349249573867251280253564698939768700489401960767007716413932851838937641880157263936985954881657889497583485535527613578457628399173971810541670838543309159139

ints = [25081841204695904475894082974192007718642931811040324543182130088804239047149283334700530600468528298920930150221871666297194395061462592781551275161695411167049544771049769000895119729307495913024360169904315078028798025169985966732789207320203861858234048872508633514498384390497048416012928086480326832803, 45471765180330439060504647480621449634904192839383897212809808339619841633826534856109999027962620381874878086991125854247108359699799913776917227058286090426484548349388138935504299609200377899052716663351188664096302672712078508601311725863678223874157861163196340391008634419348573975841578359355931590555, 17364140182001694956465593533200623738590196990236340894554145562517924989208719245429557645254953527658049246737589538280332010533027062477684237933221198639948938784244510469138826808187365678322547992099715229218615475923754896960363138890331502811292427146595752813297603265829581292183917027983351121325, 14388109104985808487337749876058284426747816961971581447380608277949200244660381570568531129775053684256071819837294436069133592772543582735985855506250660938574234958754211349215293281645205354069970790155237033436065434572020652955666855773232074749487007626050323967496732359278657193580493324467258802863, 4379499308310772821004090447650785095356643590411706358119239166662089428685562719233435615196994728767593223519226235062647670077854687031681041462632566890129595506430188602238753450337691441293042716909901692570971955078924699306873191983953501093343423248482960643055943413031768521782634679536276233318, 85256449776780591202928235662805033201684571648990042997557084658000067050672130152734911919581661523957075992761662315262685030115255938352540032297113615687815976039390537716707854569980516690246592112936796917504034711418465442893323439490171095447109457355598873230115172636184525449905022174536414781771, 50576597458517451578431293746926099486388286246142012476814190030935689430726042810458344828563913001012415702876199708216875020997112089693759638454900092580746638631062117961876611545851157613835724635005253792316142379239047654392970415343694657580353333217547079551304961116837545648785312490665576832987, 96868738830341112368094632337476840272563704408573054404213766500407517251810212494515862176356916912627172280446141202661640191237336568731069327906100896178776245311689857997012187599140875912026589672629935267844696976980890380730867520071059572350667913710344648377601017758188404474812654737363275994871, 4881261656846638800623549662943393234361061827128610120046315649707078244180313661063004390750821317096754282796876479695558644108492317407662131441224257537276274962372021273583478509416358764706098471849536036184924640593888902859441388472856822541452041181244337124767666161645827145408781917658423571721, 18237936726367556664171427575475596460727369368246286138804284742124256700367133250078608537129877968287885457417957868580553371999414227484737603688992620953200143688061024092623556471053006464123205133894607923801371986027458274343737860395496260538663183193877539815179246700525865152165600985105257601565]

qr = [a for a in ints if pow(a, (p-1)//2, p) == 1]
print(max([pow(a,(p+1)//4,p) for a in qr]))
```
``` {linenos=false}
93291799125366706806545638475797430512104976066103610269938025709952247020061090804870186195285998727680200979853848718589126765742550855954805290253592144209552123062161458584575060939481368210688629862036958857604707468372384278049741369153506182660264876115428251983455344219194133033177700490981696141526
```

## Modular Square Root
>In Legendre Symbol we introduced a fast way to determine whether a number is a square root modulo a prime. We can go further: there are algorithms for efficiently calculating such roots. The best one in practice is called Tonelli-Shanks, which gets its funny name from the fact that it was first described by an Italian in the 19th century and rediscovered independently by Daniel Shanks in the 1970s.
>
>All primes that aren't 2 are of the form `p ≡ 1 mod 4` or `p ≡ 3 mod 4`, since all odd numbers obey these congruences. As the previous challenge hinted, in the `p ≡ 3 mod 4` case, a really simple formula for computing square roots can be [derived](https://crypto.stackexchange.com/questions/20993/significance-of-3mod4-in-squares-and-square-roots-mod-n/20994#20994) directly from Fermat's little theorem. That leaves us still with the `p ≡ 1 mod 4` case, so a more general algorithm is required.
>
>In a congruence of the form `r2 ≡ a mod p`, Tonelli-Shanks calculates `r`.
>
>The main use-case for this algorithm is finding elliptic curve co-ordinates. Its operation is somewhat complex so we're not going to discuss the details, however, implementations are easy to find and Sage has one built-in.
>
>Find the square root of `a` modulo the 2048-bit prime `p`. Give the smaller of the two roots as your answer.
>
>Challenge files:
>  - output.txt

*file: output.txt*
```
a = 8479994658316772151941616510097127087554541274812435112009425778595495359700244470400642403747058566807127814165396640215844192327900454116257979487432016769329970767046735091249898678088061634796559556704959846424131820416048436501387617211770124292793308079214153179977624440438616958575058361193975686620046439877308339989295604537867493683872778843921771307305602776398786978353866231661453376056771972069776398999013769588936194859344941268223184197231368887060609212875507518936172060702209557124430477137421847130682601666968691651447236917018634902407704797328509461854842432015009878011354022108661461024768
p = 30531851861994333252675935111487950694414332763909083514133769861350960895076504687261369815735742549428789138300843082086550059082835141454526618160634109969195486322015775943030060449557090064811940139431735209185996454739163555910726493597222646855506445602953689527405362207926990442391705014604777038685880527537489845359101552442292804398472642356609304810680731556542002301547846635101455995732584071355903010856718680732337369128498655255277003643669031694516851390505923416710601212618443109844041514942401969629158975457079026906304328749039997262960301209158175920051890620947063936347307238412281568760161
```

### Solution
```python
from sage.all import *
a = 8479994658316772151941616510097127087554541274812435112009425778595495359700244470400642403747058566807127814165396640215844192327900454116257979487432016769329970767046735091249898678088061634796559556704959846424131820416048436501387617211770124292793308079214153179977624440438616958575058361193975686620046439877308339989295604537867493683872778843921771307305602776398786978353866231661453376056771972069776398999013769588936194859344941268223184197231368887060609212875507518936172060702209557124430477137421847130682601666968691651447236917018634902407704797328509461854842432015009878011354022108661461024768
p = 30531851861994333252675935111487950694414332763909083514133769861350960895076504687261369815735742549428789138300843082086550059082835141454526618160634109969195486322015775943030060449557090064811940139431735209185996454739163555910726493597222646855506445602953689527405362207926990442391705014604777038685880527537489845359101552442292804398472642356609304810680731556542002301547846635101455995732584071355903010856718680732337369128498655255277003643669031694516851390505923416710601212618443109844041514942401969629158975457079026906304328749039997262960301209158175920051890620947063936347307238412281568760161
print(mod(a,p).sqrt())
```
``` {linenos=false}
2362339307683048638327773298580489298932137505520500388338271052053734747862351779647314176817953359071871560041125289919247146074907151612762640868199621186559522068338032600991311882224016021222672243139362180461232646732465848840425458257930887856583379600967761738596782877851318489355679822813155123045705285112099448146426755110160002515592418850432103641815811071548456284263507805589445073657565381850521367969675699760755310784623577076440037747681760302434924932113640061738777601194622244192758024180853916244427254065441962557282572849162772740798989647948645207349737457445440405057156897508368531939120
```

## Chinese Remainder Theorem
>The Chinese Remainder Theorem gives a unique solution to a set of linear congruences if their moduli are coprime.
>
>This means, that given a set of arbitrary integers `ai`, and pairwise coprime integers `ni`, such that the following linear congruences hold:
``` {linenos=false}
x ≡ a1 mod n1
x ≡ a2 mod n2
...
x ≡ an mod nn
```
>There is a unique solution `x ≡ a mod N` where `N = n1 * n2 * ... * nn`.
>
>In cryptography, we commonly use the Chinese Remainder Theorem to help us reduce a problem of very large integers into a set of several, easier problems.
>
>Given the following set of linear congruences:
``` {linenos=false}
x ≡ 2 mod 5
x ≡ 3 mod 11
x ≡ 5 mod 17
```
Find the integer a such that `x ≡ a mod 935`

### Solution
Watched [this video](https://www.youtube.com/watch?v=zIFehsBHB8o) to understand the process of `crt`.

```python
from sage.all import *
print(crt([2,3,5], [5,11,17]))
```
```{linenos=false}
872
```

Alternate solution(s):
```python
# source: CryptoHack user @Hon

'''
Looking at Chinese Remainder Theorem...
Taken
        x = a1 (mod n1)
        x = a2 (mod n2)
        x = a3 (mod n3)
With gcd(n1,n2) = gcd(n1,n3) = gcd(n2,n3) = 1
        -All the n-values are coprime with the others
We have N = n1*n2*n3 and
        N1 = n2*n3
        N2 = n1*n3
        N3 = n1*n2
Summaring, the Ni values are composed multiplying all
the n-values each others, except n at position i
Ending, we call yi the solutions of Ni*yi = 1 (mod ni)
        Ex: N1 * y1 = 1 (mod n1)
Now, we have to find the value of integer a such that:
        x = a (mod N)
Knowing also that:
        x = a1N1y1 + a2N2y2 + a3N3y3 (mod N)
Easy, no?
'''
# x = 2 mod 5
# x = 3 mod 11
# x = 5 mod 17

# x = a mod 935

length = 3
a = [2,3,5]
n = [5,11,17]

Ntot= n[0] * n[1] * n[2]

N = [ n[1]*n[2] , n[0]*n[2], n[0]*n[1] ]

y = [pow(N[i],n[i]-2,n[i]) for i in range(length)]

mysterious_a = 0
for i in range(length):
        mysterious_a += a[i]*N[i]*y[i]
mysterious_a %= Ntot
print(mysterious_a)
```

## Adrien's Signs
>Adrien's been looking at ways to encrypt his messages with the help of symbols and minus signs. Can you find a way to recover the flag?
>
>Challenge files:
>  - source.py
>  - output.txt

*file: source.py*
```python
from random import randint

a = 288260533169915
p = 1007621497415251

FLAG = b'crypto{????????????????????}'


def encrypt_flag(flag):
    ciphertext = []
    plaintext = ''.join([bin(i)[2:].zfill(8) for i in flag])
    for b in plaintext:
        e = randint(1, p)
        n = pow(a, e, p)
        if b == '1':
            ciphertext.append(n)
        else:
            n = -n % p
            ciphertext.append(n)
    return ciphertext


print(encrypt_flag(FLAG))
```

*file: outut.txt*
```
[67594220461269, 501237540280788, 718316769824518, 296304224247167, 48290626940198, 30829701196032, 521453693392074, 840985324383794, 770420008897119, 745131486581197, 729163531979577, 334563813238599, 289746215495432, 538664937794468, 894085795317163, 983410189487558, 863330928724430, 996272871140947, 352175210511707, 306237700811584, 631393408838583, 589243747914057, 538776819034934, 365364592128161, 454970171810424, 986711310037393, 657756453404881, 388329936724352, 90991447679370, 714742162831112, 62293519842555, 653941126489711, 448552658212336, 970169071154259, 339472870407614, 406225588145372, 205721593331090, 926225022409823, 904451547059845, 789074084078342, 886420071481685, 796827329208633, 433047156347276, 21271315846750, 719248860593631, 534059295222748, 879864647580512, 918055794962142, 635545050939893, 319549343320339, 93008646178282, 926080110625306, 385476640825005, 483740420173050, 866208659796189, 883359067574584, 913405110264883, 898864873510337, 208598541987988, 23412800024088, 911541450703474, 57446699305445, 513296484586451, 180356843554043, 756391301483653, 823695939808936, 452898981558365, 383286682802447, 381394258915860, 385482809649632, 357950424436020, 212891024562585, 906036654538589, 706766032862393, 500658491083279, 134746243085697, 240386541491998, 850341345692155, 826490944132718, 329513332018620, 41046816597282, 396581286424992, 488863267297267, 92023040998362, 529684488438507, 925328511390026, 524897846090435, 413156582909097, 840524616502482, 325719016994120, 402494835113608, 145033960690364, 43932113323388, 683561775499473, 434510534220939, 92584300328516, 763767269974656, 289837041593468, 11468527450938, 628247946152943, 8844724571683, 813851806959975, 72001988637120, 875394575395153, 70667866716476, 75304931994100, 226809172374264, 767059176444181, 45462007920789, 472607315695803, 325973946551448, 64200767729194, 534886246409921, 950408390792175, 492288777130394, 226746605380806, 944479111810431, 776057001143579, 658971626589122, 231918349590349, 699710172246548, 122457405264610, 643115611310737, 999072890586878, 203230862786955, 348112034218733, 240143417330886, 927148962961842, 661569511006072, 190334725550806, 763365444730995, 516228913786395, 846501182194443, 741210200995504, 511935604454925, 687689993302203, 631038090127480, 961606522916414, 138550017953034, 932105540686829, 215285284639233, 772628158955819, 496858298527292, 730971468815108, 896733219370353, 967083685727881, 607660822695530, 650953466617730, 133773994258132, 623283311953090, 436380836970128, 237114930094468, 115451711811481, 674593269112948, 140400921371770, 659335660634071, 536749311958781, 854645598266824, 303305169095255, 91430489108219, 573739385205188, 400604977158702, 728593782212529, 807432219147040, 893541884126828, 183964371201281, 422680633277230, 218817645778789, 313025293025224, 657253930848472, 747562211812373, 83456701182914, 470417289614736, 641146659305859, 468130225316006, 46960547227850, 875638267674897, 662661765336441, 186533085001285, 743250648436106, 451414956181714, 527954145201673, 922589993405001, 242119479617901, 865476357142231, 988987578447349, 430198555146088, 477890180119931, 844464003254807, 503374203275928, 775374254241792, 346653210679737, 789242808338116, 48503976498612, 604300186163323, 475930096252359, 860836853339514, 994513691290102, 591343659366796, 944852018048514, 82396968629164, 152776642436549, 916070996204621, 305574094667054, 981194179562189, 126174175810273, 55636640522694, 44670495393401, 74724541586529, 988608465654705, 870533906709633, 374564052429787, 486493568142979, 469485372072295, 221153171135022, 289713227465073, 952450431038075, 107298466441025, 938262809228861, 253919870663003, 835790485199226, 655456538877798, 595464842927075, 191621819564547]
```

### Solution
First hint to the problem is the title: `Adrien's Signs`. The `Legendre symbol` was introduced by [Adrien-Marie Legendre](https://en.wikipedia.org/wiki/Adrien-Marie_Legendre), so it would seem wise to use it here. Let's look more into the code to see what's going on.

Basically, the byte letters of the plaintext flag are each converted to 8 bits (with padding of zeros). These are then joined together to make a large string of bits. For every bit, `a**randit(1,p) % p` is done to create `n`. If the bit happens to be `1`, `n` is appended to the ciphertext list - otherwise `n = -n % p` occurs before appending `n` to the list. 

So, we just need to determine whether the value is a `0` or `1` for each bit of information.

First, we ensure `a` is indeed prime.

Then, we check to make sure that `(a / p) = 1` by the `Legendre symbol` to prove `a` is quadratic residue of `mod p`. Since this is the case, all encrypted values that are also quadratic residues of `mod p` will leak the value `1` back to us. In the case of the bit being `0`, `-n mod p = a^e mod p` which becomes `n = -a^e` or `(-1/p)`:

![legendre](/img/cryptohack/legendre.png#center)
\[ *image source: https://en.wikipedia.org/wiki/Legendre_symbol* \]

Therefore, when encrypted values are non-quadratic residue, it is a `0` bit.

```python
from Crypto.Util.number import long_to_bytes

a = 288260533169915
p = 1007621497415251
enc = [67594220461269, 501237540280788, 718316769824518, 296304224247167, 48290626940198, 30829701196032, 521453693392074, 840985324383794, 770420008897119, 745131486581197, 729163531979577, 334563813238599, 289746215495432, 538664937794468, 894085795317163, 983410189487558, 863330928724430, 996272871140947, 352175210511707, 306237700811584, 631393408838583, 589243747914057, 538776819034934, 365364592128161, 454970171810424, 986711310037393, 657756453404881, 388329936724352, 90991447679370, 714742162831112, 62293519842555, 653941126489711, 448552658212336, 970169071154259, 339472870407614, 406225588145372, 205721593331090, 926225022409823, 904451547059845, 789074084078342, 886420071481685, 796827329208633, 433047156347276, 21271315846750, 719248860593631, 534059295222748, 879864647580512, 918055794962142, 635545050939893, 319549343320339, 93008646178282, 926080110625306, 385476640825005, 483740420173050, 866208659796189, 883359067574584, 913405110264883, 898864873510337, 208598541987988, 23412800024088, 911541450703474, 57446699305445, 513296484586451, 180356843554043, 756391301483653, 823695939808936, 452898981558365, 383286682802447, 381394258915860, 385482809649632, 357950424436020, 212891024562585, 906036654538589, 706766032862393, 500658491083279, 134746243085697, 240386541491998, 850341345692155, 826490944132718, 329513332018620, 41046816597282, 396581286424992, 488863267297267, 92023040998362, 529684488438507, 925328511390026, 524897846090435, 413156582909097, 840524616502482, 325719016994120, 402494835113608, 145033960690364, 43932113323388, 683561775499473, 434510534220939, 92584300328516, 763767269974656, 289837041593468, 11468527450938, 628247946152943, 8844724571683, 813851806959975, 72001988637120, 875394575395153, 70667866716476, 75304931994100, 226809172374264, 767059176444181, 45462007920789, 472607315695803, 325973946551448, 64200767729194, 534886246409921, 950408390792175, 492288777130394, 226746605380806, 944479111810431, 776057001143579, 658971626589122, 231918349590349, 699710172246548, 122457405264610, 643115611310737, 999072890586878, 203230862786955, 348112034218733, 240143417330886, 927148962961842, 661569511006072, 190334725550806, 763365444730995, 516228913786395, 846501182194443, 741210200995504, 511935604454925, 687689993302203, 631038090127480, 961606522916414, 138550017953034, 932105540686829, 215285284639233, 772628158955819, 496858298527292, 730971468815108, 896733219370353, 967083685727881, 607660822695530, 650953466617730, 133773994258132, 623283311953090, 436380836970128, 237114930094468, 115451711811481, 674593269112948, 140400921371770, 659335660634071, 536749311958781, 854645598266824, 303305169095255, 91430489108219, 573739385205188, 400604977158702, 728593782212529, 807432219147040, 893541884126828, 183964371201281, 422680633277230, 218817645778789, 313025293025224, 657253930848472, 747562211812373, 83456701182914, 470417289614736, 641146659305859, 468130225316006, 46960547227850, 875638267674897, 662661765336441, 186533085001285, 743250648436106, 451414956181714, 527954145201673, 922589993405001, 242119479617901, 865476357142231, 988987578447349, 430198555146088, 477890180119931, 844464003254807, 503374203275928, 775374254241792, 346653210679737, 789242808338116, 48503976498612, 604300186163323, 475930096252359, 860836853339514, 994513691290102, 591343659366796, 944852018048514, 82396968629164, 152776642436549, 916070996204621, 305574094667054, 981194179562189, 126174175810273, 55636640522694, 44670495393401, 74724541586529, 988608465654705, 870533906709633, 374564052429787, 486493568142979, 469485372072295, 221153171135022, 289713227465073, 952450431038075, 107298466441025, 938262809228861, 253919870663003, 835790485199226, 655456538877798, 595464842927075, 191621819564547]

# Check if prime is of the form p ≡ 3 mod 4 (not p ≡ 1 mod 4)
# pow(a, (p-1)//2, p) == kronecker(a,p)
assert kronecker(a, p) == 1

pt_bits = '0b'
for x in enc:
    # pow(x, (p-1)//2, p) == kronecker(x,p)
    qr = kronecker(x, p)
    if qr == 1:
        pt_bits += '1'
    else:
        # qr == p-1 => 1007621497415250
        pt_bits += '0'

pt_int = int(pt_bits,2)
print(long_to_bytes(pt_int))
```

``` {linenos=false}
b'crypto{p4tterns_1n_re5idu3s}'
```

## Modular Binomials
>Rearrange the following equations to get the primes p,q
```{linenos=false}
N = p*q
c1 = (2*p + 3*q)**e1 mod N
c2 = (5*p + 7*q)**e2 mod N
```
>Challenge files:
>  - data.txt

*file: data.txt*
```
N = 14905562257842714057932724129575002825405393502650869767115942606408600343380327866258982402447992564988466588305174271674657844352454543958847568190372446723549627752274442789184236490768272313187410077124234699854724907039770193680822495470532218905083459730998003622926152590597710213127952141056029516116785229504645179830037937222022291571738973603920664929150436463632305664687903244972880062028301085749434688159905768052041207513149370212313943117665914802379158613359049957688563885391972151218676545972118494969247440489763431359679770422939441710783575668679693678435669541781490217731619224470152467768073
e1 = 12886657667389660800780796462970504910193928992888518978200029826975978624718627799215564700096007849924866627154987365059524315097631111242449314835868137
e2 = 12110586673991788415780355139635579057920926864887110308343229256046868242179445444897790171351302575188607117081580121488253540215781625598048021161675697
c1 = 14010729418703228234352465883041270611113735889838753433295478495763409056136734155612156934673988344882629541204985909650433819205298939877837314145082403528055884752079219150739849992921393509593620449489882380176216648401057401569934043087087362272303101549800941212057354903559653373299153430753882035233354304783275982332995766778499425529570008008029401325668301144188970480975565215953953985078281395545902102245755862663621187438677596628109967066418993851632543137353041712721919291521767262678140115188735994447949166616101182806820741928292882642234238450207472914232596747755261325098225968268926580993051
c2 = 14386997138637978860748278986945098648507142864584111124202580365103793165811666987664851210230009375267398957979494066880296418013345006977654742303441030008490816239306394492168516278328851513359596253775965916326353050138738183351643338294802012193721879700283088378587949921991198231956871429805847767716137817313612304833733918657887480468724409753522369325138502059408241232155633806496752350562284794715321835226991147547651155287812485862794935695241612676255374480132722940682140395725089329445356434489384831036205387293760789976615210310436732813848937666608611803196199865435145094486231635966885932646519
```

### Solution
Unintended solution is [factordb](http://factordb.com/index.php?query=14905562257842714057932724129575002825405393502650869767115942606408600343380327866258982402447992564988466588305174271674657844352454543958847568190372446723549627752274442789184236490768272313187410077124234699854724907039770193680822495470532218905083459730998003622926152590597710213127952141056029516116785229504645179830037937222022291571738973603920664929150436463632305664687903244972880062028301085749434688159905768052041207513149370212313943117665914802379158613359049957688563885391972151218676545972118494969247440489763431359679770422939441710783575668679693678435669541781490217731619224470152467768073)!

```{linenos=false}
p = 112274000169258486390262064441991200608556376127408952701514962644340921899196091557519382763356534106376906489445103255177593594898966250176773605432765983897105047795619470659157057093771407309168345670541418772427807148039207489900810013783673957984006269120652134007689272484517805398390277308001719431273

q = 132760587806365301971479157072031448380135765794466787456948786731168095877956875295282661565488242190731593282663694728914945967253173047324353981530949360031535707374701705328450856944598803228299967009004598984671293494375599408764139743217465012770376728876547958852025425539298410751132782632817947101601
```

Alternate solution(s):
```python
# source: CryptoHack user @diksown

from fractions import gcd
N = 14905562257842714057932724129575002825405393502650869767115942606408600343380327866258982402447992564988466588305174271674657844352454543958847568190372446723549627752274442789184236490768272313187410077124234699854724907039770193680822495470532218905083459730998003622926152590597710213127952141056029516116785229504645179830037937222022291571738973603920664929150436463632305664687903244972880062028301085749434688159905768052041207513149370212313943117665914802379158613359049957688563885391972151218676545972118494969247440489763431359679770422939441710783575668679693678435669541781490217731619224470152467768073
e1 = 12886657667389660800780796462970504910193928992888518978200029826975978624718627799215564700096007849924866627154987365059524315097631111242449314835868137
e2 = 12110586673991788415780355139635579057920926864887110308343229256046868242179445444897790171351302575188607117081580121488253540215781625598048021161675697
c1 = 14010729418703228234352465883041270611113735889838753433295478495763409056136734155612156934673988344882629541204985909650433819205298939877837314145082403528055884752079219150739849992921393509593620449489882380176216648401057401569934043087087362272303101549800941212057354903559653373299153430753882035233354304783275982332995766778499425529570008008029401325668301144188970480975565215953953985078281395545902102245755862663621187438677596628109967066418993851632543137353041712721919291521767262678140115188735994447949166616101182806820741928292882642234238450207472914232596747755261325098225968268926580993051
c2 = 14386997138637978860748278986945098648507142864584111124202580365103793165811666987664851210230009375267398957979494066880296418013345006977654742303441030008490816239306394492168516278328851513359596253775965916326353050138738183351643338294802012193721879700283088378587949921991198231956871429805847767716137817313612304833733918657887480468724409753522369325138502059408241232155633806496752350562284794715321835226991147547651155287812485862794935695241612676255374480132722940682140395725089329445356434489384831036205387293760789976615210310436732813848937666608611803196199865435145094486231635966885932646519
#N = p*q
#c1 = (2*p + 3*q)**e1 mod N
#c2 = (5*p + 7*q)**e2 mod N 
#c1^e2 = (2*p + 3*q)**(e1*e2) mod N
#c2^e1 = (5*p + 7*q)**(e1*e2) mod N
#f1 = 5^e1*e2 * c1^e2 = (10*p + 15*q)**(e1*e2) mod N
#f2 = 2^e1*e2 * c2^e1 = (10*p + 14*q)**(e1*e2) mod N
#f1 mod q = f2 mod q => f1-f2 = 0 mod q
f1 = pow(5, e1*e2, N) * pow(c1, e2, N)
f2 = pow(2, e1*e2, N) * pow(c2, e1, N)
q = abs(gcd(N, f1-f2))
p = N//q
print(N, p, q, N-p*q, sep='\n')
```

*source: CryptoHack user @exp101t*
![bionomials](/img/cryptohack/bionomials.png)
```python
from math import gcd

n = 14905562257842714057932724129575002825405393502650869767115942606408600343380327866258982402447992564988466588305174271674657844352454543958847568190372446723549627752274442789184236490768272313187410077124234699854724907039770193680822495470532218905083459730998003622926152590597710213127952141056029516116785229504645179830037937222022291571738973603920664929150436463632305664687903244972880062028301085749434688159905768052041207513149370212313943117665914802379158613359049957688563885391972151218676545972118494969247440489763431359679770422939441710783575668679693678435669541781490217731619224470152467768073
e1 = 12886657667389660800780796462970504910193928992888518978200029826975978624718627799215564700096007849924866627154987365059524315097631111242449314835868137
e2 = 12110586673991788415780355139635579057920926864887110308343229256046868242179445444897790171351302575188607117081580121488253540215781625598048021161675697
c1 = 14010729418703228234352465883041270611113735889838753433295478495763409056136734155612156934673988344882629541204985909650433819205298939877837314145082403528055884752079219150739849992921393509593620449489882380176216648401057401569934043087087362272303101549800941212057354903559653373299153430753882035233354304783275982332995766778499425529570008008029401325668301144188970480975565215953953985078281395545902102245755862663621187438677596628109967066418993851632543137353041712721919291521767262678140115188735994447949166616101182806820741928292882642234238450207472914232596747755261325098225968268926580993051
c2 = 14386997138637978860748278986945098648507142864584111124202580365103793165811666987664851210230009375267398957979494066880296418013345006977654742303441030008490816239306394492168516278328851513359596253775965916326353050138738183351643338294802012193721879700283088378587949921991198231956871429805847767716137817313612304833733918657887480468724409753522369325138502059408241232155633806496752350562284794715321835226991147547651155287812485862794935695241612676255374480132722940682140395725089329445356434489384831036205387293760789976615210310436732813848937666608611803196199865435145094486231635966885932646519

q1 = pow(c1, e2, n)
q2 = pow(c2, e1, n)

d = pow(5, e1 * e2, n) * q1 - pow(2, e1 * e2, n) * q2

q = gcd(d, n)
p = n // q

assert(p * q == n)
```